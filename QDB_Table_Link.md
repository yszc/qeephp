# 什么叫做关联 #

数据表关联是指两个或者多个数据表的**记录之间的逻辑关系** 。

比如一篇文章（一篇文章保存为“文章”数据表的一条记录）有多个评论（一个评论保存为“评论”数据表的一条记录）。那么就可以说“文章”对于“评论”是一个 **“一对多”** 的关系。

从现实角度，只有“一对一”和“一对多”两种关系。但由于关系式数据库不能直接存储数据之间的关系，所以两种关系扩展为 **“一对一”** 、 **“一对多”** 、 **“从属”** 和 **“多对多”** 四种关系。

如果加上更多的限制条件，四种关联还可以扩展出更多类型的关联。例如“一对多”通常表示一个事物 **“拥有（HAS）”** 多个其他事物，但有时也可以表示一个事物和多个事物相关，但并不能够决定这些事物的存在。

典型的例子就是文章与评论。文章“拥有”多个评论，因为评论是不能单独存在的，必定是属于一个文章。但同样是“一对多”，一个分类对应多个商品就不同。虽然商品必定属于一个分类，但是在删除分类时，如果有属于该分类的商品，要么是禁止删除分类，要么是将属于该分类的商品划分到另一个分类。

四种关联的特点、区别以及适用场合，会在后面的内容详细说明。

# 关联、主表和关联表的概念 #

在 QeePHP 中，关联是指两个数据表之间的逻辑关系，并用一个 QDB\_Table\_Link 对象封装。
而主表，则是关联关系中，占据主动地位的一方。而关联表则是被主表所关联的数据表。

例如，“文章”数据表关联到“评论”数据表：

```
 QDB_Table 对象            QDB_Table 对象
       |                           |
       |                           |
  +--------+                  +--------+
  | 文章表 | ---- 一对多 ---> | 评论表 |
  +--------+                  +--------+
     主表        关联关系       关联表
                    |
                    |
        封装为一个 QDB_Table_Link 对象
```

通常，一个关联关系总是存在一个反向的关联。
例如对于上面的“文章”关联到“评论”，就存在一个反向的“评论”到“文章”的关联关系：

```
+--------+                  +--------+
| 评论表 | ---- 从属于 ---> | 文章表 |
+--------+                  +--------+
```

不过在实际开发中，应该尽量避免不必要的关联定义。

# QeePHP 对四种关联的支持 #

QDB\_Table\_Link 对四种数据表关联提供了全面的支持，包括自动查询关联数据、自动创建关联数据，以及维护关联关系等特征。

对于所有类型的关联，都支持以下功能：

  * 查询主表时，自动查询关联表数据
  * 查询关联表数据时，进行排序
  * 查询关联表数据时，使用字段别名
  * 可以指定要查询的关联表字段
  * 可以指定查询关联表时要使用的查询条件
  * 可以限定查询关联表时返回的记录数
  * 可以在删除主表记录时，自动删除关联表的记录
  * 可以在创建主表记录时，自动创建关联表的记录

不过四种关联在对各项功能的支持上，具有不同的默认设置：

  * has one 一对一
  * has many 一对多
    * 创建主表记录时，如果包含关联表记录，则自动创建关联表记录
    * 删除主表记录时，自动删除关联的记录

  * belongs to 从属
    * 不会自动创建关联记录
    * 不会自动删除关联的记录

  * many to many 多对多
    * 自动创建关联记录
    * 自动通过中间表维护主表和关联表之间的关系
    * 不会自动删除关联的记录

# 如何定义一个关联 #

在定义一个数据表的关联时，通过表数据入口继承类的 $has\_one、$has\_many、$belongs\_to 和 $many\_to\_many 进行。

例如：

```
/**
 * Table_Contents 类封装了 contents 表的操作以及与相关表的关联操作
 */
class Table_Contents extends QDB_Table
{
    /**
     * 不包含全局前缀的数据表名称
     *
     * @var string
     */
    public $table_name = 'contents';

    /**
     * 主键字段名
     *
     * @var string
     */
    public $pk = 'content_id';

    /**
     * belongs to 关联
     *
     * @var array
     */
    protected $belongs_to = array(
        /**
         * 每个内容都有一个作者
         */
        array(
            /**
             * 指示关联到哪一个表数据入口类
             */
            'table_class'   => 'Table_Authors',

            /**
             * 指示关联的名称，以及关联数据在保存主表记录的数组中用什么名字引用
             */
            'mapping_name'  => 'author',

            /**
             * 指示在主表中用什么字段和关联表记录进行关联
             */
            'main_key'      => 'author_id',

            /**
             * 指示在 Table_Authors 封装的数据表中使用什么字段存储关联内容的记录总数
             */
            'count_cache'   => 'contents_count',

            /**
             * 指示在读取作者信息时，只获取作者表的哪些字段
             */
            'on_find_fields' => array('author_id', 'name' => 'name_alias'),
        ),
    );
}
```

因为有可能需要定义多个同一种类型的关联，所以 $has\_one、$has\_many、$belongs\_to 和 $many\_to\_many 成员变量的格式都是一个二维数组。

```
protected $has_one = array(
    // 第一个 has one 关联
    array(
        .....
    ),

    // 第二个 has one 关联
    array(
        .....
    ),
);
```

## 定义关联时可以指定的选项 ##

定义关联时，可以指定不同的选项，从而改变关联的行为。

可用的选项如下：

### 指定要关联的数据表 ###

**assoc\_table\_obj**

关联的表数据入口对象实例。通常用于动态构造关联时使用已有的表数据入口对象。

**assoc\_table\_class**

关联到哪一个表数据入口类。

**assoc\_table\_name**

关联到哪一个数据表。如果使用 assoc\_table\_name 直接指定要关联的数据表，则会创建一个匿名的表数据入口对象来处理关联操作。

注意：assoc\_table\_obj、assoc\_table\_class、assoc\_table\_name 三者只需要指定一个，三者的优先级从上到下。

如果 assoc\_table\_name 有效，则可以通过 assoc\_table\_xxxx 等一系列参数指示构造关联表数据入口时的选项。可用的 assoc\_table\_xxxx 系列选项有：

  * assoc\_table\_pk 关联数据表的主键
  * assoc\_table\_schema 关联数据表所属 schema

### 指定关联的名称 ###

**mapping\_name**

指定关联的名称，以及关联数据在保存主表记录的数组中用什么名字引用。

例如“文章”表有一个 has many 关联指向“评论”表，这个关联的 mapping\_name 为 'comments'。那么在查询文章表数据时，文章相关的评论数据会以 'comments' 为键名保存在文章表数据数组中。

```
$article = $table_articles->find(....)->query();
// 输出文章的评论数据
print_r($article['comments']);
```

mapping\_name 同时定义了关联的名称。因此在调用表数据入口对象的 getLink() 等方法时，需要以 mapping\_name 指定的值作为参数来操作特定的关联。

同样，在保存主表的数据时，关联对象也通过 mapping\_name 去查找主表数据数组中包含的关联表数据。从而实现自动创建关联表记录等功能。

### 指定用于关联的字段 ###

**main\_key**

指示在主表中用什么字段和关联表记录进行关联。如果没有指定 main\_key，会按照下面的规则取默认值：
  * 对于 has many 和 has one 关联，main\_key 的默认值是主表的主键字段
  * 对于 belongs to 关联，main\_key 的默认值是主表中与关联表主键字段同名的字段
  * 对于 many to many 关联，main\_key 的默认值是主表的主键字段

**assoc\_key**

关联关系在关联表中使用哪一个字段。同样，该选项可以自动设置：
  * 对于 has many、has one 关联，assoc\_key 的默认值是关联表中与主表主键字段同名的字段
  * 对于 belongs to 关联，assoc\_key 的默认值是关联表的主键字段
  * 对于 many to many 关联，assoc\_key 的默认值是关联表的主键字段

### 查询关联表时的行为 ###

**on\_find**

指示是否读取关联的记录

| true 或 'all'   | 读取所有关联记录 |
|:-----------------|:-------------------------|
| false 或 'skip' | 跳过，不读取内容记录 |
| 整数            | 仅读取指定个数的内容记录，例如 on\_find = 5 表示仅读取每个作者的 5 个内容记录 |
| 数组            | 包含读取起始位置和要读取的个数，例如 array($offset, $nums) |

对于所有类型的关联，on\_find 的默认值都是 true。

**on\_find\_where**

指示读取关联表数据时，要使用的查询条件。具体的查询条件构造，参考[查询对象](QTable_Select.md)介绍中关于如何使用复杂查询条件的部分。

**on\_find\_order**

指示按照什么排序规则查询关联的记录，如果为空字符串或 null，则表示查询关联时不排序。on\_find\_order 的默认值是 null。

**on\_find\_fields**

指示在读取关联记录时，只获取关联记录的哪些字段。on\_find\_fields 的默认值是 '**'，表示读取关联表的所有字段。**

**on\_delete**

指示在删除主表记录时，如何处理关联的记录：

| true 或 'cascade' | 删除所有的关联记录 |
|:-------------------|:----------------------------|
| 'set\_null'        | 将关联记录的外键字段设置为 NULL |
| 'set\_value'       | 将关联记录的外键字段设置为指定的值 |
| false 或 'skip'   | 不处理关联记录 |

对于 belongs to 和 many to many 关联，on\_delete 的默认值是 'skip'；
对于 has many 和 has one 关联，默认值则是 'cascade'。

**on\_delete\_set\_value**

如果 on\_delete 为 'set\_value'，则通过 on\_delete\_set\_value 指定要填充的值。on\_delete\_set\_value 的默认值为 null。

**on\_save**

指示是否保存关联的记录：

| true 或 'save'  | 根据关联记录是否具有主键值来决定是创建记录还是更新现有记录 |
|:-----------------|:----------------------------------------------------------------------------------------|
| 'create'        | 强制创建新记录 |
| 'update'        | 强制更新记录 |
| 'replace'       | 使用数据库的 replace 操作来尝试替换记录 |
| false 或 'skip' | 不处理关联记录 |
| 'only\_create'   | 仅仅保存需要创建的记录（根据是否具备主键值判断） |
| 'only\_update'   | 仅仅保存需要更新的记录（根据是否具备主键值判断） |

对于 belongs to 和 many to many 关联，on\_save 的默认值是 'skip'；
对于 has many 和 has one 关联，on\_save 的默认值是 'save'。

### 仅用于 many to many 关联的选项 ###

**mid\_main\_key**

指示在中间表中，用哪个字段存储对主表的 main\_key 引用。mid\_main\_key 的默认值是中间表中与 main\_key 选项值同名的字段。

**mid\_assoc\_key**

指示在中间表中，用哪个字段存储对关联表的 assoc\_key 引用。mid\_assoc\_key 的默认值是中间表中与 assoc\_key 选项值同名的字段。

**mid\_table\_obj**

指示操作中间表的表数据入口对象实例。

**mid\_table\_class**

指示用哪一个表数据入口对象封装对中间表的操作。

**mid\_table\_name**

指示中间表的名称。

mid\_table\_obj、mid\_table\_class、mid\_table\_name 三者只需要指定一个，三者的优先级从上到下。
如果 mid\_table\_name 有效，则可以通过 mid\_table\_xxxx 等一系列参数指示构造关联表数据入口时的选项。

**mid\_on\_find\_fields**

指示查询 many to many 关联时，中间表的哪些字段要包含在查询结果中：

| 空字符串 或 null  | 不查询中间表的字段 |
|:-----------------------|:----------------------------|
| 星号              | 查询中间表的所有字段 |
| 字段列表          | 以逗号分隔的字段名或者包含字段名的数组 |

mid\_on\_find\_fields 的默认值是 null。

**mid\_on\_find\_prefix**

指示查询 many to many 关联，中间表的字段包含在查询结果中时要加上什么前缀。mid\_on\_find\_prefix 的默认值是 'mid